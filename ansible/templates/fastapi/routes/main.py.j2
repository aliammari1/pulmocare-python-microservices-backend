from typing import List, Optional
import logging
from uuid import uuid4

from fastapi import APIRouter, HTTPException, Query, Depends, status
from fastapi.responses import JSONResponse

from config import Config
from models.base import (
    {{ service_name.title() }},
    {{ service_name.title() }}Create,
    {{ service_name.title() }}Update,
    {{ service_name.title() }}Response,
    {{ service_name.title() }}ListResponse,
    BaseResponse,
    ErrorResponse,
    PaginationMeta
)

logger = logging.getLogger(__name__)
router = APIRouter()

# In-memory storage for demonstration - replace with actual database
# TODO: Replace with actual database operations
_{{ service_name }}_storage: List[{{ service_name.title() }}] = []


def get_{{ service_name }}_by_id({{ service_name }}_id: str) -> Optional[{{ service_name.title() }}]:
    """Get {{ service_name }} by ID."""
    for item in _{{ service_name }}_storage:
        if item.id == pharmacy_id:
            return item
    return None


@router.get("/{{ service_name }}", response_model={{ service_name | title }}ListResponse)
async def list_{{ service_name }}(
    page: int = Query(1, ge=1, description="Page number"),
    per_page: int = Query(10, ge=1, le=100, description="Items per page"),
    search: Optional[str] = Query(None, description="Search term"),
    active_only: bool = Query(True, description="Filter active items only")
) -> {{ service_name | title }}ListResponse:
    """
    List {{ service_name }} items with pagination and filtering.
    
    - **page**: Page number (starts from 1)
    - **per_page**: Number of items per page (1-100)
    - **search**: Search term to filter by name or description
    - **active_only**: Whether to show only active items
    """
    try:
        # Filter items
        filtered_items = _{{ service_name }}_storage.copy()
        
        if active_only:
            filtered_items = [item for item in filtered_items if item.is_active]
        
        if search:
            search_lower = search.lower()
            filtered_items = [
                item for item in filtered_items
                if (search_lower in item.name.lower() or 
                    (item.description and search_lower in item.description.lower()))
            ]
        
        # Pagination
        total = len(filtered_items)
        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        items = filtered_items[start_idx:end_idx]
        
        # Calculate pagination metadata
        total_pages = (total + per_page - 1) // per_page
        has_prev = page > 1
        has_next = page < total_pages
        
        meta = PaginationMeta(
            page=page,
            per_page=per_page,
            total=total,
            pages=total_pages,
            has_prev=has_prev,
            has_next=has_next
        )
        
        return {{ service_name | title }}ListResponse(data=items, meta=meta)
        
    except Exception as e:
        logger.error(f"Error listing {{ service_name }}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to list {{ service_name }} items"
        )


@router.post("/{{ service_name }}", response_model={{ service_name | title }}Response, status_code=status.HTTP_201_CREATED)
async def create_{{ service_name }}(
    {{ service_name }}_data: {{ service_name | title }}Create
) -> {{ service_name | title }}Response:
    """
    Create a new {{ service_name }} item.
    
    - **name**: {{ service_name | title }} name (required)
    - **description**: {{ service_name | title }} description (optional)
    """
    try:
        from datetime import datetime
        
        # Create new {{ service_name }}
        new_{{ service_name }} = {{ service_name | title }}(
            id=str(uuid4()),
            name={{ service_name }}_data.name,
            description={{ service_name }}_data.description,
            created_at=datetime.now(),
            updated_at=datetime.now(),
            is_active=True
        )
        
        # Add to storage
        _{{ service_name }}_storage.append(new_{{ service_name }})
        
        logger.info(f"Created {{ service_name }}: {new_{{ service_name }}.id}")
        
        return {{ service_name | title }}Response(
            message="{{ service_name | title }} created successfully",
            data=new_{{ service_name }}
        )
        
    except Exception as e:
        logger.error(f"Error creating {{ service_name }}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create {{ service_name }}"
        )


@router.get("/{{ service_name }}/{{{ service_name }}_id}", response_model={{ service_name | title }}Response)
async def get_{{ service_name }}({{ service_name }}_id: str) -> {{ service_name | title }}Response:
    """
    Get a specific {{ service_name }} by ID.
    
    - **{{ service_name }}_id**: The ID of the {{ service_name }} to retrieve
    """
    try:
        {{ service_name }}_item = get_{{ service_name }}_by_id({{ service_name }}_id)
        
        if not {{ service_name }}_item:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"{{ service_name | title }} with ID {{{ service_name }}_id} not found"
            )
        
        return {{ service_name | title }}Response(
            message="{{ service_name | title }} retrieved successfully",
            data={{ service_name }}_item
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting {{ service_name }} {{{ service_name }}_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve {{ service_name }}"
        )


@router.put("/{{ service_name }}/{{{ service_name }}_id}", response_model={{ service_name | title }}Response)
async def update_{{ service_name }}(
    {{ service_name }}_id: str,
    {{ service_name }}_data: {{ service_name | title }}Update
) -> {{ service_name | title }}Response:
    """
    Update a specific {{ service_name }} by ID.
    
    - **{{ service_name }}_id**: The ID of the {{ service_name }} to update
    - **name**: Updated {{ service_name }} name (optional)
    - **description**: Updated {{ service_name }} description (optional)
    - **is_active**: Updated active status (optional)
    """
    try:
        {{ service_name }}_item = get_{{ service_name }}_by_id({{ service_name }}_id)
        
        if not {{ service_name }}_item:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"{{ service_name | title }} with ID {{{ service_name }}_id} not found"
            )
        
        # Update fields if provided
        update_data = {{ service_name }}_data.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr({{ service_name }}_item, field, value)
        
        # Update timestamp
        from datetime import datetime
        {{ service_name }}_item.updated_at = datetime.now()
        
        logger.info(f"Updated {{ service_name }}: {{{ service_name }}_id}")
        
        return {{ service_name | title }}Response(
            message="{{ service_name | title }} updated successfully",
            data={{ service_name }}_item
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating {{ service_name }} {{{ service_name }}_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update {{ service_name }}"
        )


@router.delete("/{{ service_name }}/{{{ service_name }}_id}", response_model=BaseResponse)
async def delete_{{ service_name }}({{ service_name }}_id: str) -> BaseResponse:
    """
    Delete a specific {{ service_name }} by ID.
    
    - **{{ service_name }}_id**: The ID of the {{ service_name }} to delete
    """
    try:
        {{ service_name }}_item = get_{{ service_name }}_by_id({{ service_name }}_id)
        
        if not {{ service_name }}_item:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"{{ service_name | title }} with ID {{{ service_name }}_id} not found"
            )
        
        # Remove from storage
        _{{ service_name }}_storage.remove({{ service_name }}_item)
        
        logger.info(f"Deleted {{ service_name }}: {{{ service_name }}_id}")
        
        return BaseResponse(
            message="{{ service_name | title }} deleted successfully"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting {{ service_name }} {{{ service_name }}_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete {{ service_name }}"
        )


@router.post("/{{ service_name }}/{{{ service_name }}_id}/activate", response_model={{ service_name | title }}Response)
async def activate_{{ service_name }}({{ service_name }}_id: str) -> {{ service_name | title }}Response:
    """
    Activate a specific {{ service_name }} by ID.
    
    - **{{ service_name }}_id**: The ID of the {{ service_name }} to activate
    """
    try:
        {{ service_name }}_item = get_{{ service_name }}_by_id({{ service_name }}_id)
        
        if not {{ service_name }}_item:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"{{ service_name | title }} with ID {{{ service_name }}_id} not found"
            )
        
        {{ service_name }}_item.is_active = True
        from datetime import datetime
        {{ service_name }}_item.updated_at = datetime.now()
        
        logger.info(f"Activated {{ service_name }}: {{{ service_name }}_id}")
        
        return {{ service_name | title }}Response(
            message="{{ service_name | title }} activated successfully",
            data={{ service_name }}_item
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error activating {{ service_name }} {{{ service_name }}_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to activate {{ service_name }}"
        )


@router.post("/{{ service_name }}/{{{ service_name }}_id}/deactivate", response_model={{ service_name | title }}Response)
async def deactivate_{{ service_name }}({{ service_name }}_id: str) -> {{ service_name | title }}Response:
    """
    Deactivate a specific {{ service_name }} by ID.
    
    - **{{ service_name }}_id**: The ID of the {{ service_name }} to deactivate
    """
    try:
        {{ service_name }}_item = get_{{ service_name }}_by_id({{ service_name }}_id)
        
        if not {{ service_name }}_item:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"{{ service_name | title }} with ID {{{ service_name }}_id} not found"
            )
        
        {{ service_name }}_item.is_active = False
        from datetime import datetime
        {{ service_name }}_item.updated_at = datetime.now()
        
        logger.info(f"Deactivated {{ service_name }}: {{{ service_name }}_id}")
        
        return {{ service_name | title }}Response(
            message="{{ service_name | title }} deactivated successfully",
            data={{ service_name }}_item
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deactivating {{ service_name }} {{{ service_name }}_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to deactivate {{ service_name }}"
        )
